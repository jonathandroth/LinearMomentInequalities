%This function computes the (modified) least favorable critical values for
%the linear programming approach

%It takes as input

%X_T: the matrix of derivatives, i.e. true moments are of hte form Y_T -
%  X_T * delta

%Z_draws: a matrix of standard normal draws

%Sigma: a covariance matrix

%alpha: significance level

%Note Sigma and X_T are assumed to have been normalized so that Sigma has
%diagonal of ones



function [lf_critical_value_fn, eta_vec] = lf_critical_value_fn(X, Z_draws, Sigma, alpha)
%% Computing the least-favorable critical value from Andrews, Roth and Pakes for testing moments of the form E[Y_i - X_i delta | Z_i] <= 0
%Inputs:
% X: the (scaled) sample average of X_i (a k x m vector)
% Z_draws: a matrix of standard normal draws of dimension k x S, where S is
% the number of simulations for the CV (we recommend 1000). This can be
% drawn onc
% Sigma: the (scaled) estimate of E[ Var(Y_i|Z_i) ]
% alpha: the size of the test (e.g. 0.05 for 5% significance)
%Outputs:
% reject: does the test reject
% eta: the test statistic
%Notes:
% If y and X are sample averages, Sigma should be E[ Var(Y|X) ] /N
% If Sigma is E[ Var(Y|X) ], then y and X should be averages scaled by sqrt(N)

Sigma_sqrt = Sigma^(1/2);
eps_draws = Sigma_sqrt * Z_draws;

numsims = size(Z_draws,2);
eta_vec = NaN(numsims,1);
for s = 1:numsims
    
    y_T_s = eps_draws(:,s);
    eta_vec(s,1) = etahat_fn(y_T_s, X, Sigma);
end


lf_critical_value_fn = quantile( eta_vec, 1-alpha);

end
